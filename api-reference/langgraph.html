<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangGraph API - LangChain 1.0</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body class="chapter-api-langgraph">
    <button class="theme-toggle">ğŸŒ“</button>
    <button class="mobile-menu-btn" onclick="toggleSidebar()">â˜°</button>

    <div class="app-container">
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1>LangChain 1.0</h1>
                <p style="color: rgba(255,255,255,0.6); font-size: 0.9rem; margin-top: 5px;">API å‚è€ƒ</p>
            </div>
            <div class="sidebar-nav"></div>
        </nav>

        <main class="main-content">
            <div class="content">
                <h1>LangGraph API</h1>
                <p class="subtitle">çŠ¶æ€å›¾å·¥ä½œæµä¸å¾ªç¯ç¼–æ’</p>

                <div class="api-nav">
                    <a href="#overview" class="api-nav-link">æ¦‚è¿°</a>
                    <a href="#state-graph" class="api-nav-link">StateGraph</a>
                    <a href="#nodes" class="api-nav-link">èŠ‚ç‚¹</a>
                    <a href="#edges" class="api-nav-link">è¾¹</a>
                    <a href="#examples" class="api-nav-link">ç¤ºä¾‹</a>
                </div>

                <h2 id="overview">æ¦‚è¿°</h2>
                <p>LangGraph æ˜¯ LangChain çš„çŠ¶æ€å›¾ç¼–æ’åº“ï¼Œç”¨äºæ„å»ºæœ‰çŠ¶æ€ã€å¤šå‚ä¸è€…çš„å¾ªç¯åº”ç”¨ï¼Œæ”¯æŒå¤æ‚çš„å·¥ä½œæµå’Œæ¡ä»¶è·¯ç”±ã€‚</p>

                <pre class="mermaid">graph TD
    A[StateGraph] --> B[add_node]
    A --> C[add_edge]
    A --> D[add_conditional_edges]
    A --> E[set_entry_point]
    A --> F[set_finish_point]

    C --> G[æ™®é€šè¾¹]
    D --> H[æ¡ä»¶è¾¹]
    E --> I[èµ·å§‹ç‚¹]
    F --> J[ç»“æŸç‚¹]

    A --> K[compile]
    K --> L[CompiledGraph]
    L --> M[invoke]
    L --> N[stream]
    L --> O[batch]

    style A fill:#e1f5fe
    style L fill:#c8e6c9</code></pre>

                <h2 id="state-graph">StateGraph</h2>

                <div class="api-section">
                    <h3 class="api-title">StateGraph</h3>
                    <p class="api-description">çŠ¶æ€å›¾æ ¸å¿ƒç±»ã€‚</p>

                    <div class="api-signature">
                        <pre><code class="language-python">from langgraph.graph import StateGraph

class StateGraph:
    """çŠ¶æ€å›¾ç±»"""

    def __init__(
        self,
        schema: Type[TypedDict] | Dict[str, Any],
        *,
        config_schema: Optional[Type[TypedDict]] = None,
    ):
        """
        åˆå§‹åŒ–çŠ¶æ€å›¾

        Args:
            schema: çŠ¶æ€æ¨¡å¼ï¼ˆTypedDict æˆ–å­—å…¸ï¼‰
            config_schema: å¯é€‰çš„é…ç½®æ¨¡å¼
        """</code></pre>
                    </div>

                    <h4>æ ¸å¿ƒæ–¹æ³•</h4>
                    <div class="api-signature">
                        <pre><code class="language-python">def add_node(
    self,
    name: str,
    func: Callable,
    *,
    metadata: Optional[Dict[str, Any]] = None,
) -> None:
    """
    æ·»åŠ èŠ‚ç‚¹

    Args:
        name: èŠ‚ç‚¹åç§°
        func: èŠ‚ç‚¹å‡½æ•°ï¼Œæ¥æ”¶ stateï¼Œè¿”å›æ›´æ–°
        metadata: å¯é€‰çš„å…ƒæ•°æ®
    """

def add_edge(
    self,
    start_key: str,
    end_key: str,
) -> None:
    """
    æ·»åŠ æ™®é€šè¾¹ï¼ˆæ— æ¡ä»¶è½¬ç§»ï¼‰

    Args:
        start_key: èµ·å§‹èŠ‚ç‚¹
        end_key: ç›®æ ‡èŠ‚ç‚¹
    """

def add_conditional_edges(
    self,
    source: str,
    path: Callable | Mapping[str, str],
    path_map: Optional[Mapping[str, str]] = None,
) -> None:
    """
    æ·»åŠ æ¡ä»¶è¾¹

    Args:
        source: æºèŠ‚ç‚¹
        path: è·¯ç”±å‡½æ•°æˆ–è¾¹æ˜ å°„
        path_map: å¯é€‰çš„è¾¹ååˆ°èŠ‚ç‚¹æ˜ å°„
    """

def set_entry_point(
    self,
    entry_point: str,
) -> None:
    """
    è®¾ç½®å…¥å£ç‚¹

    Args:
        entry_point: èµ·å§‹èŠ‚ç‚¹åç§°
    """

def set_finish_point(
    self,
    finish_point: str,
) -> None:
    """
    è®¾ç½®ç»“æŸç‚¹

    Args:
        finish_point: ç»“æŸèŠ‚ç‚¹åç§°
    """

def compile(
    self,
    *,
    checkpointer: Optional[BaseCheckpointSaver] = None,
    interrupt_before: Optional[set[str]] = None,
    interrupt_after: Optional[set[str]] = None,
    debug: bool = False,
) -> CompiledGraph:
    """
    ç¼–è¯‘çŠ¶æ€å›¾

    Args:
        checkpointer: æ£€æŸ¥ç‚¹ä¿å­˜å™¨ï¼ˆç”¨äºæŒä¹…åŒ–ï¼‰
        interrupt_before: åœ¨è¿™äº›èŠ‚ç‚¹å‰ä¸­æ–­
        interrupt_after: åœ¨è¿™äº›èŠ‚ç‚¹åä¸­æ–­
        debug: æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼

    Returns:
        ç¼–è¯‘åçš„å›¾
    """</code></pre>
                    </div>

                    <h4>ä½¿ç”¨ç¤ºä¾‹</h4>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-language">python</span>
                            <button class="copy-btn">å¤åˆ¶</button>
                        </div>
                        <pre><code class="language-python">from langgraph.graph import StateGraph, END
from typing import TypedDict

# å®šä¹‰çŠ¶æ€
class GraphState(TypedDict):
    messages: list[str]
    current_step: str

# åˆ›å»ºçŠ¶æ€å›¾
graph = StateGraph(GraphState)

# å®šä¹‰èŠ‚ç‚¹å‡½æ•°
def node_a(state: GraphState) -> dict:
    return {"current_step": "A completed"}

def node_b(state: GraphState) -> dict:
    return {"current_step": "B completed"}

def node_c(state: GraphState) -> dict:
    return {"current_step": "C completed"}

# æ·»åŠ èŠ‚ç‚¹
graph.add_node("a", node_a)
graph.add_node("b", node_b)
graph.add_node("c", node_c)

# è®¾ç½®å…¥å£
graph.set_entry_point("a")

# æ·»åŠ è¾¹
graph.add_edge("a", "b")
graph.add_edge("b", "c")
graph.add_edge("c", END)

# ç¼–è¯‘
app = graph.compile()</code></pre>
                    </div>
                </div>

                <h2 id="nodes">èŠ‚ç‚¹</h2>

                <div class="api-section">
                    <h3 class="api-title">èŠ‚ç‚¹å‡½æ•°</h3>
                    <p class="api-description">èŠ‚ç‚¹å‡½æ•°å®šä¹‰æ¯ä¸ªèŠ‚ç‚¹çš„è¡Œä¸ºã€‚</p>

                    <div class="api-signature">
                        <pre><code class="language-python">from typing import Annotated
from langgraph.graph import StateGraph

# ========== åŸºç¡€èŠ‚ç‚¹ ==========
def simple_node(state: GraphState) -> dict:
    """
    åŸºç¡€èŠ‚ç‚¹å‡½æ•°

    Args:
        state: å½“å‰çŠ¶æ€

    Returns:
        çŠ¶æ€æ›´æ–°å­—å…¸ï¼ˆä¼šè¢«åˆå¹¶åˆ°ç°æœ‰çŠ¶æ€ï¼‰
    """
    return {"messages": ["new message"]}

# ========== ä½¿ç”¨ reduce æ“ä½œæ›´æ–° ==========
from typing import Sequence
from operator import add

class StateWithReduce(TypedDict):
    # Annotated å®šä¹‰å¦‚ä½•æ›´æ–°å­—æ®µ
    messages: Annotated[Sequence[str], add]

def reduce_node(state: StateWithReduce) -> dict:
    # è¿”å›çš„åˆ—è¡¨ä¼šè¢«è¿½åŠ ï¼ˆä¸æ˜¯æ›¿æ¢ï¼‰
    return {"messages": ["appended message"]}

# ========== è°ƒç”¨ LLM çš„èŠ‚ç‚¹ ==========
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-4o")

def llm_node(state: GraphState) -> dict:
    """è°ƒç”¨ LLM çš„èŠ‚ç‚¹"""
    messages = state["messages"]
    response = llm.invoke(messages)
    return {"messages": [response.content]}

# ========== å·¥å…·è°ƒç”¨èŠ‚ç‚¹ ==========
from langchain_core.tools import tool

@tool
def search(query: str) -> str:
    """æœç´¢å·¥å…·"""
    return f"æœç´¢ç»“æœ: {query}"

def tools_node(state: GraphState) -> dict:
    """ä½¿ç”¨å·¥å…·çš„èŠ‚ç‚¹"""
    result = search.invoke(state["query"])
    return {"output": result}</code></pre>
                    </div>
                </div>

                <div class="api-section">
                    <h3 class="api-title">ToolNode</h3>
                    <p class="api-description">é¢„æ„å»ºçš„å·¥å…·èŠ‚ç‚¹ã€‚</p>

                    <div class="api-signature">
                        <pre><code class="language-python">from langgraph.prebuilt import ToolNode

class ToolNode:
    """å·¥å…·èŠ‚ç‚¹

    è¿è¡Œå·¥å…·å¹¶å¤„ç†å·¥å…·è°ƒç”¨
    """

    def __init__(
        self,
        tools: Sequence[BaseTool],
    ):
        """
        åˆå§‹åŒ–

        Args:
            tools: å·¥å…·åˆ—è¡¨
        """

    def __call__(
        self,
        state: GraphState,
        config: RunnableConfig,
    ) -> dict:
        """
        æ‰§è¡Œå·¥å…·è°ƒç”¨

        Args:
            state: åŒ…å« tool_calls çš„çŠ¶æ€
            config: è¿è¡Œé…ç½®

        Returns:
            åŒ…å«å·¥å…·æ¶ˆæ¯çš„çŠ¶æ€æ›´æ–°
        """</code></pre>
                    </div>

                    <h4>ä½¿ç”¨ç¤ºä¾‹</h4>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-language">python</span>
                            <button class="copy-btn">å¤åˆ¶</button>
                        </div>
                        <pre><code class="language-python">from langgraph.prebuilt import ToolNode
from langchain_core.tools import tool

@tool
def get_weather(city: str) -> str:
    return f"{city} æ™´å¤©ï¼Œ25Â°C"

@tool
def get_time() -> str:
    from datetime import datetime
    return datetime.now().strftime("%H:%M:%S")

# åˆ›å»ºå·¥å…·èŠ‚ç‚¹
tools = [get_weather, get_time]
tool_node = ToolNode(tools)

# æ·»åŠ åˆ°å›¾ä¸­
graph.add_node("tools", tool_node)</code></pre>
                    </div>
                </div>

                <h2 id="edges">è¾¹</h2>

                <div class="api-section">
                    <h3 class="api-title">æ™®é€šè¾¹</h3>
                    <p class="api-description">æ— æ¡ä»¶è½¬ç§»çš„è¾¹ã€‚</p>

                    <div class="api-signature">
                        <pre><code class="language-python">from langgraph.graph import StateGraph, END

graph = StateGraph(GraphState)

# A -> B: ç›´æ¥è¿æ¥
graph.add_edge("node_a", "node_b")

# B -> END: ç»“æŸ
graph.add_edge("node_b", END)

# å¤šèŠ‚ç‚¹é“¾
graph.add_edge("start", "process")
graph.add_edge("process", "validate")
graph.add_edge("validate", "output")
graph.add_edge("output", END)</code></pre>
                    </div>
                </div>

                <div class="api-section">
                    <h3 class="api-title">æ¡ä»¶è¾¹</h3>
                    <p class="api-description">æ ¹æ®çŠ¶æ€å†³å®šä¸‹ä¸€æ­¥çš„è¾¹ã€‚</p>

                    <div class="api-signature">
                        <pre><code class="language-python">def route_function(
    state: GraphState,
) -> str:
    """
    è·¯ç”±å‡½æ•°

    Args:
        state: å½“å‰çŠ¶æ€

    Returns:
        ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åç§°
    """
    if state.get("should_continue"):
        return "continue"
    else:
        return "end"

# ä½¿ç”¨å‡½æ•°è·¯ç”±
graph.add_conditional_edges(
    "decision_node",
    route_function,
    {
        "continue": "process_node",
        "end": END
    }
)

# ========== ä½¿ç”¨å­—å…¸è·¯ç”± ==========
# ç®€åŒ–å†™æ³•ï¼šçŠ¶æ€å­—æ®µç›´æ¥æ˜ å°„åˆ°èŠ‚ç‚¹
graph.add_conditional_edges(
    "decision_node",
    {
        "approve": "approved_node",
        "reject": "rejected_node",
        "review": "review_node"
    }
)</code></pre>
                    </div>
                </div>

                <h2 id="examples">ä½¿ç”¨ç¤ºä¾‹</h2>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python"># ========== ç¤ºä¾‹1: ç®€å•æµç¨‹å›¾ ==========
from langgraph.graph import StateGraph, END
from typing import TypedDict

class ProcessState(TypedDict):
    input: str
    processed: bool
    output: str

def process_node(state: ProcessState) -> dict:
    return {"processed": True, "output": state["input"].upper()}

graph = StateGraph(ProcessState)
graph.add_node("process", process_node)
graph.set_entry_point("process")
graph.add_edge("process", END)

app = graph.compile()
result = app.invoke({"input": "hello"})
# {"input": "hello", "processed": True, "output": "HELLO"}

# ========== ç¤ºä¾‹2: æ¡ä»¶è·¯ç”± ==========
class RoutingState(TypedDict):
    score: float
    result: str

def evaluate(state: RoutingState) -> dict:
    score = len(state["result"])  # ç®€å•è¯„åˆ†
    return {"score": score}

def route_logic(state: RoutingState) -> str:
    if state["score"] > 10:
        return "high"
    elif state["score"] > 5:
        return "medium"
    return "low"

def high_handler(state: RoutingState) -> dict:
    return {"result": "é«˜åˆ†å¤„ç†"}

def medium_handler(state: RoutingState) -> dict:
    return {"result": "ä¸­ç­‰åˆ†å¤„ç†"}

def low_handler(state: RoutingState) -> dict:
    return {"result": "ä½åˆ†å¤„ç†"}

graph = StateGraph(RoutingState)
graph.add_node("evaluate", evaluate)
graph.add_node("high", high_handler)
graph.add_node("medium", medium_handler)
graph.add_node("low", low_handler)

graph.set_entry_point("evaluate")
graph.add_conditional_edges(
    "evaluate",
    route_logic,
    {"high": "high", "medium": "medium", "low": "low"}
)
graph.add_edge("high", END)
graph.add_edge("medium", END)
graph.add_edge("low", END)

# ========== ç¤ºä¾‹3: å¾ªç¯å›¾ ==========
class LoopState(TypedDict):
    count: int
    max: int
    result: str

def increment(state: LoopState) -> dict:
    new_count = state["count"] + 1
    return {"count": new_count}

def should_continue(state: LoopState) -> str:
    if state["count"] < state["max"]:
        return "continue"
    return "end"

graph = StateGraph(LoopState)
graph.add_node("increment", increment)
graph.set_entry_point("increment")

graph.add_conditional_edges(
    "increment",
    should_continue,
    {"continue": "increment", "end": END}
)

# å¾ªç¯ 5 æ¬¡
app = graph.compile()
result = app.invoke({"count": 0, "max": 5})
# {"count": 5, "max": 5, "result": ""}

# ========== ç¤ºä¾‹4: Agent å¾ªç¯ ==========
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import ToolNode
from langchain_core.tools import tool

@tool
def search(query: str) -> str:
    return "æœç´¢ç»“æœ"

class AgentState(TypedDict):
    messages: list

llm = ChatOpenAI(model="gpt-4o").bind_tools([search])

def agent_node(state: AgentState) -> dict:
    response = llm.invoke(state["messages"])
    return {"messages": [response]}

def should_continue(state: AgentState) -> str:
    last_message = state["messages"][-1]
    if hasattr(last_message, "tool_calls") and last_message.tool_calls:
        return "tools"
    return END

graph = StateGraph(AgentState)
graph.add_node("agent", agent_node)
graph.add_node("tools", ToolNode([search]))

graph.set_entry_point("agent")
graph.add_conditional_edges("agent", should_continue)
graph.add_edge("tools", "agent")

# ========== ç¤ºä¾‹5: å¸¦æ£€æŸ¥ç‚¹çš„å›¾ ==========
from langgraph.checkpoint.memory import MemorySaver

class State(TypedDict):
    step: int
    data: str

def step_node(state: State) -> dict:
    return {"step": state["step"] + 1}

graph = StateGraph(State)
graph.add_node("step", step_node)
graph.set_entry_point("step")
graph.add_edge("step", END)

# æ·»åŠ æ£€æŸ¥ç‚¹
checkpointer = MemorySaver()
app = graph.compile(checkpointer=checkpointer)

# ä½¿ç”¨çº¿ç¨‹ ID
config = {"configurable": {"thread_id": "session-1"}}
result = app.invoke({"step": 0, "data": "test"}, config)

# æ¢å¤çŠ¶æ€
state = app.get_state(config)
print(state.values)  # {"step": 1, "data": "test"}

# ========== ç¤ºä¾‹6: å­å›¾ï¼ˆåµŒå¥—å›¾ï¼‰=========
# åˆ›å»ºå­å›¾
def subgraph_builder():
    sub_graph = StateGraph(SubState)
    sub_graph.add_node("sub_a", sub_node_a)
    sub_graph.add_node("sub_b", sub_node_b)
    sub_graph.set_entry_point("sub_a")
    sub_graph.add_edge("sub_a", "sub_b")
    sub_graph.add_edge("sub_b", END)
    return sub_graph.compile()

# æ·»åŠ åˆ°ä¸»å›¾
graph.add_node("subgraph", subgraph_builder())
graph.add_edge("start", "subgraph")
graph.add_edge("subgraph", END)

# ========== ç¤ºä¾‹7: äººå·¥å®¡æ ¸ ==========
class HumanState(TypedDict):
    input: str
    approved: bool

def prepare(state: HumanState) -> dict:
    return {"input": state["input"]}

def human_review(state: HumanState) -> dict:
    # ç­‰å¾…äººå·¥è¾“å…¥
    print(f"å®¡æ ¸: {state['input']}")
    choice = input("æ‰¹å‡†? (y/n): ")
    return {"approved": choice.lower() == "y"}

def final_output(state: HumanState) -> dict:
    return {"result": "å·²æ‰¹å‡†" if state["approved"] else "å·²æ‹’ç»"}

graph = StateGraph(HumanState)
graph.add_node("prepare", prepare)
graph.add_node("human_review", human_review)
graph.add_node("output", final_output)

graph.set_entry_point("prepare")
graph.add_edge("prepare", "human_review")
graph.add_edge("human_review", "output")
graph.add_edge("output", END)

# ä¸­æ–­ç­‰å¾…äººå·¥è¾“å…¥
app = graph.compile(interrupt_before=["human_review"])</code></pre>
                </div>

                <h2>ç›¸å…³ API</h2>
                <ul>
                    <li><a href="chains.html">Chains API</a></li>
                    <li><a href="agents.html">Agents API</a></li>
                    <li><a href="../17-langgraph.html">æ•™ç¨‹ï¼šLangGraph å·¥ä½œæµ</a></li>
                </ul>

                <div class="chapter-nav">
                    <a href="evaluators.html">â† Evaluators API</a>
                </div>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="../assets/js/main.js"></script>
</body>
</html>
