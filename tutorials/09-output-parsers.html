<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¾“å‡ºè§£æ - LangChain 1.0 çŸ¥è¯†ç‚¹</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body class="chapter-output-parsers">
    <button class="theme-toggle">ğŸŒ“</button>
    <button class="mobile-menu-btn" onclick="toggleSidebar()">â˜°</button>

    <div class="app-container">
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1><a href="../index.html" style="color: white; text-decoration: none;">LangChain 1.0</a></h1>
                <p style="color: rgba(255,255,255,0.6); font-size: 0.9rem; margin-top: 5px;">çŸ¥è¯†ç‚¹</p>
            </div>
            <div class="sidebar-nav"></div>
        </nav>

        <main class="main-content">
            <div class="content">
                <h1>è¾“å‡ºè§£æ</h1>
                <p class="subtitle">å°† LLM çš„è¾“å‡ºè½¬æ¢ä¸ºç»“æ„åŒ–æ•°æ®</p>

                <h2>ä¸ºä»€ä¹ˆéœ€è¦è¾“å‡ºè§£æï¼Ÿ</h2>
                <p>LLM é»˜è®¤è¾“å‡ºçš„æ˜¯çº¯æ–‡æœ¬ï¼Œä½†åœ¨å®é™…åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸éœ€è¦ç»“æ„åŒ–æ•°æ®ï¼š</p>
                <ul>
                    <li><strong>æ•°æ®åº“æ“ä½œ</strong>ï¼šéœ€è¦æå– SQL æŸ¥è¯¢å‚æ•°</li>
                    <li><strong>API è°ƒç”¨</strong>ï¼šéœ€è¦è§£æ JSON æ ¼å¼çš„å‚æ•°</li>
                    <li><strong>æ•°æ®å½•å…¥</strong>ï¼šéœ€è¦æå–ç‰¹å®šå­—æ®µï¼ˆå§“åã€æ—¥æœŸã€é‡‘é¢ç­‰ï¼‰</li>
                    <li><strong>æ¡ä»¶åˆ¤æ–­</strong>ï¼šéœ€è¦æ ¹æ®è¾“å‡ºæ‰§è¡Œä¸åŒæ“ä½œ</li>
                </ul>

                <div class="tip" data-label="æç¤º">
                    è¾“å‡ºè§£æå™¨å°±åƒä¸€ä¸ª"ç¿»è¯‘å®˜"â€”â€”æŠŠ LLM çš„è‡ªç„¶è¯­è¨€è¾“å‡ºç¿»è¯‘æˆä½ çš„ç¨‹åºå¯ä»¥ç†è§£å’Œä½¿ç”¨çš„æ•°æ®æ ¼å¼ã€‚
                </div>

                <h2>è¾“å‡ºè§£ææµç¨‹</h2>

                <pre class="mermaid">graph LR
    A[ç”¨æˆ·è¾“å…¥] --> B[LLM å¤„ç†]
    B --> C[åŸå§‹æ–‡æœ¬è¾“å‡º]
    C --> D[Output Parser]
    D --> E[ç»“æ„åŒ–æ•°æ®]
    E --> F[åº”ç”¨ä½¿ç”¨]

    D --> G{è§£æç±»å‹?}
    G -->|JSON| H[PydanticOutputParser]
    G -->|åˆ—è¡¨| I[CommaSeparatedListOutputParser]
    G -->|è‡ªå®šä¹‰| J[è‡ªå®šä¹‰ Parser]

    style D fill:#fff9c4
    style E fill:#c8e6c9</code></pre>

                <h2>PydanticOutputParserï¼ˆJSON è§£æï¼‰</h2>
                <p>æœ€å¸¸ç”¨çš„è§£æå™¨ï¼Œå°† LLM è¾“å‡ºè§£æä¸º JSON å¯¹è±¡ï¼š</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python">from langchain_core.output_parsers import PydanticOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field

# 1. å®šä¹‰è¾“å‡ºæ•°æ®æ¨¡å‹
class Person(BaseModel):
    """äººç‰©ä¿¡æ¯"""
    name: str = Field(description="äººç‰©å§“å")
    age: int = Field(description="äººç‰©å¹´é¾„")
    occupation: str = Field(description="èŒä¸š")
    skills: list[str] = Field(description="æŠ€èƒ½åˆ—è¡¨")

# 2. åˆ›å»ºè§£æå™¨
parser = PydanticOutputParser(pydantic_object=Person)

# 3. æŸ¥çœ‹è§£æå™¨ç”Ÿæˆçš„æ ¼å¼è¯´æ˜
print("æ ¼å¼è¯´æ˜:")
print(parser.get_format_instructions())
# è¾“å‡ºç±»ä¼¼ï¼š
# The output should be formatted as a JSON instance that conforms to the JSON schema below...
# {"name": "...", "age": ..., "occupation": "...", "skills": [...]}

# 4. åˆ›å»ºæç¤ºæ¨¡æ¿ï¼ˆåŒ…å«æ ¼å¼è¯´æ˜ï¼‰
prompt = PromptTemplate(
    template="åˆ†æä»¥ä¸‹æ–‡æœ¬ï¼Œæå–äººç‰©ä¿¡æ¯ã€‚\n\n{format_instructions}\n\næ–‡æœ¬å†…å®¹ï¼š{text}\n\n",
    input_variables=["text"],
    partial_variables={"format_instructions": parser.get_format_instructions()}
)

# 5. æ„å»ºé“¾å¹¶æ‰§è¡Œ
llm = ChatOpenAI(model="gpt-4o", temperature=0)

chain = prompt | llm | parser

# 6. æ‰§è¡Œ
text = "å¼ ä¸‰ä»Šå¹´28å²ï¼Œæ˜¯ä¸€åè½¯ä»¶å·¥ç¨‹å¸ˆï¼Œæ“…é•¿Pythonã€JavaScriptå’Œæœºå™¨å­¦ä¹ ã€‚"
result = chain.invoke({"text": text})

print(f"å§“å: {result.name}")
print(f"å¹´é¾„: {result.age}")
print(f"èŒä¸š: {result.occupation}")
print(f"æŠ€èƒ½: {result.skills}")
# å§“å: å¼ ä¸‰
# å¹´é¾„: 28
# èŒä¸š: è½¯ä»¶å·¥ç¨‹å¸ˆ
# æŠ€èƒ½: ['Python', 'JavaScript', 'æœºå™¨å­¦ä¹ ']</code></pre>
                </div>

                <div class="note" data-label="æ³¨æ„">
                    <code>PydanticOutputParser</code> ä¼šè‡ªåŠ¨åœ¨æç¤ºä¸­æ·»åŠ æ ¼å¼è¯´æ˜ï¼Œå¹¶å¤„ç† LLM è¾“å‡ºä¸­çš„ JSON è§£æé”™è¯¯ã€‚
                </div>

                <h2>å¤„ç†å¤æ‚åµŒå¥—ç»“æ„</h2>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python">from typing import List
from pydantic import BaseModel, Field

class Address(BaseModel):
    """åœ°å€ä¿¡æ¯"""
    street: str = Field(description="è¡—é“åœ°å€")
    city: str = Field(description="åŸå¸‚")
    country: str = Field(description="å›½å®¶")

class Company(BaseModel):
    """å…¬å¸ä¿¡æ¯"""
    name: str = Field(description="å…¬å¸åç§°")
    industry: str = Field(description="è¡Œä¸š")
    employee_count: int = Field(description="å‘˜å·¥æ•°é‡")

class UserProfile(BaseModel):
    """ç”¨æˆ·å®Œæ•´èµ„æ–™"""
    user_id: str = Field(description="ç”¨æˆ·ID")
    username: str = Field(description="ç”¨æˆ·å")
    email: str = Field(description="ç”µå­é‚®ç®±")
    address: Address = Field(description="åœ°å€ä¿¡æ¯")
    companies: List[Company] = Field(description="å·¥ä½œç»å†")

# è§£æå¤æ‚åµŒå¥—ç»“æ„
parser = PydanticOutputParser(pydantic_object=UserProfile)

# ä½¿ç”¨ç¤ºä¾‹
text = """
ç”¨æˆ·ID: USER12345
ç”¨æˆ·å: tech_master
é‚®ç®±: master@example.com

åœ°å€: åŒ—äº¬å¸‚æµ·æ·€åŒºä¸­å…³æ‘å¤§è¡—1å·ï¼Œä¸­å›½

å·¥ä½œç»å†:
1. è…¾è®¯ - äº’è”ç½‘ - 50000äºº
2. å­—èŠ‚è·³åŠ¨ - äº’è”ç½‘ - 100000äºº
"""

chain = prompt | llm | parser
result = chain.invoke({"text": text})

print(result.model_dump_json(indent=2))
# {
#   "user_id": "USER12345",
#   "username": "tech_master",
#   "email": "master@example.com",
#   "address": {
#     "street": "ä¸­å…³æ‘å¤§è¡—1å·",
#     "city": "åŒ—äº¬å¸‚",
#     "country": "ä¸­å›½"
#   },
#   "companies": [...]
# }</code></pre>
                </div>

                <h2>CommaSeparatedListOutputParser</h2>
                <p>è§£æé€—å·åˆ†éš”çš„åˆ—è¡¨ï¼š</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python">from langchain_core.output_parsers import CommaSeparatedListOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 1. åˆ›å»ºåˆ—è¡¨è§£æå™¨
parser = CommaSeparatedListOutputParser()

# 2. è·å–æ ¼å¼è¯´æ˜
format_instructions = parser.get_format_instructions()
print(format_instructions)
# è¾“å‡ºï¼šYour response should be a list of comma separated values, eg: `foo, bar, baz`

# 3. åˆ›å»ºæç¤º
prompt = PromptTemplate(
    template="åˆ—å‡ºä»¥ä¸‹ä¸»é¢˜ç›¸å…³çš„5ä¸ªå…³é”®è¯ã€‚\n\n{format_instructions}\n\nä¸»é¢˜ï¼š{topic}",
    input_variables=["topic"],
    partial_variables={"format_instructions": format_instructions}
)

# 4. æ„å»ºé“¾
chain = prompt | ChatOpenAI(temperature=0) | parser

# 5. æ‰§è¡Œ
result = chain.invoke({"topic": "äººå·¥æ™ºèƒ½"})
print(result)
# è¾“å‡ºï¼š['æœºå™¨å­¦ä¹ ', 'æ·±åº¦å­¦ä¹ ', 'è‡ªç„¶è¯­è¨€å¤„ç†', 'è®¡ç®—æœºè§†è§‰', 'å¼ºåŒ–å­¦ä¹ ']

# å¯ä»¥ç›´æ¥ä½œä¸ºåˆ—è¡¨ä½¿ç”¨
for keyword in result:
    print(f"- {keyword}")</code></pre>
                </div>

                <h2>StructuredOutputParser</h2>
                <p>å¦ä¸€ç§ç»“æ„åŒ–è¾“å‡ºæ–¹å¼ï¼Œä½¿ç”¨ ResponseSchemaï¼š</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python">from langchain_core.output_parsers import StructuredOutputParser, ResponseSchema
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 1. å®šä¹‰å“åº”æ¨¡å¼
response_schemas = [
    ResponseSchema(
        name="summary",
        description="æ–‡æœ¬å†…å®¹çš„ç®€è¦æ‘˜è¦ï¼Œä¸è¶…è¿‡50å­—"
    ),
    ResponseSchema(
        name="keywords",
        description="ä»æ–‡æœ¬ä¸­æå–çš„å…³é”®è¯åˆ—è¡¨"
    ),
    ResponseSchema(
        name="sentiment",
        description="æ–‡æœ¬çš„æƒ…æ„Ÿå€¾å‘ï¼ˆæ­£é¢/è´Ÿé¢/ä¸­æ€§ï¼‰"
    )
]

# 2. åˆ›å»ºè§£æå™¨
parser = StructuredOutputParser.from_response_schemas(response_schemas)

# 3. åˆ›å»ºæç¤º
prompt = PromptTemplate(
    template="åˆ†æä»¥ä¸‹æ–‡æœ¬ï¼š\n\n{text}\n\n{format_instructions}",
    input_variables=["text"],
    partial_variables={"format_instructions": parser.get_format_instructions()}
)

# 4. æ„å»ºé“¾
chain = prompt | ChatOpenAI(temperature=0) | parser

# 5. æ‰§è¡Œ
text = "ä»Šå¤©å¤©æ°”çœŸä¸é”™ï¼Œé˜³å…‰æ˜åªšï¼Œå¿ƒæƒ…ç‰¹åˆ«å¥½ï¼å†³å®šå‡ºå»æ•£æ­¥ã€‚"
result = chain.invoke({"text": text})

print(result)
# è¾“å‡ºï¼š
# {
#   'summary': 'æè¿°äº†å¥½å¤©æ°”å¸¦æ¥çš„æ„‰å¿«å¿ƒæƒ…',
#   'keywords': ['å¤©æ°”', 'é˜³å…‰', 'å¿ƒæƒ…', 'æ•£æ­¥'],
#   'sentiment': 'æ­£é¢'
# }</code></pre>
                </div>

                <h2>è‡ªå®šä¹‰ Output Parser</h2>
                <p>å½“å†…ç½®è§£æå™¨æ— æ³•æ»¡è¶³éœ€æ±‚æ—¶ï¼Œå¯ä»¥åˆ›å»ºè‡ªå®šä¹‰è§£æå™¨ï¼š</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python">from langchain_core.outputs import Generation
from langchain_core.exceptions import OutputParserException
from langchain_core.output_parsers import BaseOutputParser

# è‡ªå®šä¹‰è§£æå™¨ï¼šæå–æ—¥æœŸ
class DateExtractorParser(BaseOutputParser):
    """ä»æ–‡æœ¬ä¸­æå–æ—¥æœŸä¿¡æ¯"""

    def parse(self, text: str) -> dict:
        """è§£æ LLM è¾“å‡º"""
        import re
        from datetime import datetime

        # åŒ¹é…å¸¸è§æ—¥æœŸæ ¼å¼
        date_patterns = [
            r'\d{4}-\d{2}-\d{2}',  # 2024-01-15
            r'\d{4}å¹´\d{1,2}æœˆ\d{1,2}æ—¥',  # 2024å¹´1æœˆ15æ—¥
            r'\d{1,2}/\d{1,2}/\d{4}',  # 1/15/2024
        ]

        dates = []
        for pattern in date_patterns:
            matches = re.findall(pattern, text)
            dates.extend(matches)

        return {
            "dates_found": dates,
            "count": len(dates)
        }

    def get_format_instructions(self) -> str:
        """è¿”å›æ ¼å¼è¯´æ˜"""
        return "è¯·ä»æ–‡æœ¬ä¸­æå–æ‰€æœ‰æ—¥æœŸä¿¡æ¯ï¼ŒåŒ…æ‹¬å…·ä½“æ—¥æœŸã€‚"

# ä½¿ç”¨è‡ªå®šä¹‰è§£æå™¨
parser = DateExtractorParser()

# æ–¹æ³•1ï¼šç›´æ¥è§£ææ–‡æœ¬
text = "ä¼šè®®å®‰æ’åœ¨2024å¹´3æœˆ15æ—¥ï¼Œå¦ä¸€ä¸ªä¼šè®®æ˜¯2024-04-20"
result = parser.parse(text)
print(result)
# {'dates_found': ['2024å¹´3æœˆ15æ—¥', '2024-04-20'], 'count': 2}

# æ–¹æ³•2ï¼šä¸ LLM é›†æˆ
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

prompt = PromptTemplate(
    template="ä»ä»¥ä¸‹æ–‡æœ¬ä¸­æå–æ‰€æœ‰æ—¥æœŸï¼š\n\n{text}",
    input_variables=["text"]
)

chain = prompt | ChatOpenAI() | parser
result = chain.invoke({"text": text})
print(result)</code></pre>
                </div>

                <h2>å¸¦é”™è¯¯å¤„ç†çš„è§£æå™¨</h2>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python">from langchain_core.output_parsers import OutputFixingParser
from langchain_openai import ChatOpenAI

# å½“è§£æå¤±è´¥æ—¶ï¼Œè‡ªåŠ¨è®© LLM ä¿®æ­£è¾“å‡º
base_parser = PydanticOutputParser(pydantic_object=Person)

# åˆ›å»ºä¿®å¤è§£æå™¨
fixing_parser = OutputFixingParser.from_llm(
    parser=base_parser,
    llm=ChatOpenAI(model="gpt-4")
)

# å³ä½¿ LLM è¾“å‡ºæ ¼å¼æœ‰é—®é¢˜ï¼Œä¹Ÿä¼šè‡ªåŠ¨ä¿®æ­£
bad_llm_output = "å§“åï¼šå¼ ä¸‰ï¼Œå¹´é¾„ï¼š28å²"

try:
    # base_parser ä¼šå¤±è´¥
    result = base_parser.parse(bad_llm_output)
except Exception as e:
    print(f"åŸºç¡€è§£æå™¨å¤±è´¥: {e}")

# fixing_parser ä¼šè‡ªåŠ¨ä¿®æ­£
result = fixing_parser.parse(bad_llm_output)
print(f"ä¿®å¤åç»“æœ: {result}")</code></pre>
                </div>

                <h2>ä¸æµå¼è¾“å‡ºç»“åˆ</h2>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">python</span>
                        <button class="copy-btn">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-python">from langchain_core.output_parsers import JsonOutputParser

# JsonOutputParser æ”¯æŒæµå¼å¤„ç†
parser = JsonOutputParser()

# æ„å»ºé“¾
chain = prompt | ChatOpenAI() | parser

# æµå¼è¾“å‡º
for chunk in chain.stream({"text": "..."}):
    print(chunk, end="", flush=True)
# é€å—è¾“å‡ºè§£æåçš„ JSON</code></pre>
                </div>

                <h2>è¾“å‡ºè§£æå™¨é€‰æ‹©å†³ç­–æ ‘</h2>

                <pre class="mermaid">graph TD
    A[éœ€è¦ä»€ä¹ˆè¾“å‡ºæ ¼å¼?] --> B{æ•°æ®ç±»å‹?}
    B -->|JSONå¯¹è±¡| C[PydanticOutputParser]
    B -->|ç®€å•åˆ—è¡¨| D[CommaSeparatedListOutputParser]
    B -->|é”®å€¼å¯¹| E[StructuredOutputParser]
    B -->|è‡ªå®šä¹‰| F[è‡ªå®šä¹‰ Parser]

    C --> C1{éœ€è¦éªŒè¯?}
    C1 -->|æ˜¯| C2[ä½¿ç”¨ Pydantic æ¨¡å‹]
    C1 -->|å¦| C3[JsonOutputParser]

    F --> F1{å¤æ‚åº¦?}
    F1 -->|ç®€å•| F2[ç»§æ‰¿ BaseOutputParser]
    F1 -->|éœ€è¦ä¿®å¤| F3[OutputFixingParser]

    style C fill:#c8e6c9
    style F3 fill:#fff9c4</code></pre>

                <h2>æœ€ä½³å®è·µ</h2>

                <div class="practice" data-label="å®è·µå»ºè®®">
                    <h3>1. é€‰æ‹©åˆé€‚çš„è§£æå™¨</h3>
                    <ul>
                        <li>JSON å¯¹è±¡ï¼šä½¿ç”¨ <code>PydanticOutputParser</code></li>
                        <li>ç®€å•åˆ—è¡¨ï¼šä½¿ç”¨ <code>CommaSeparatedListOutputParser</code></li>
                        <li>è‡ªå®šä¹‰å­—æ®µï¼šä½¿ç”¨ <code>StructuredOutputParser</code></li>
                    </ul>

                    <h3>2. æä¾›æ¸…æ™°çš„æ ¼å¼è¯´æ˜</h3>
                    <ul>
                        <li>åœ¨æç¤ºä¸­æ˜ç¡®è¯´æ˜æœŸæœ›çš„è¾“å‡ºæ ¼å¼</li>
                        <li>æä¾›ç¤ºä¾‹ï¼ˆFew-shotï¼‰å¸®åŠ© LLM ç†è§£</li>
                        <li>ä½¿ç”¨ <code>get_format_instructions()</code> è·å–æ ‡å‡†è¯´æ˜</li>
                    </ul>

                    <h3>3. å¤„ç†è§£æé”™è¯¯</h3>
                    <ul>
                        <li>ä½¿ç”¨ <code>OutputFixingParser</code> è‡ªåŠ¨ä¿®å¤</li>
                        <li>æ·»åŠ é‡è¯•é€»è¾‘</li>
                        <li>è®°å½•è§£æå¤±è´¥çš„æ¡ˆä¾‹ç”¨äºè°ƒè¯•</li>
                    </ul>

                    <h3>4. ä¼˜åŒ–å­—æ®µæè¿°</h3>
                    <ul>
                        <li>åœ¨ <code>Field</code> ä¸­æä¾›è¯¦ç»†çš„æè¿°ä¿¡æ¯</li>
                        <li>è¯´æ˜æ•°æ®ç±»å‹å’Œçº¦æŸæ¡ä»¶</li>
                        <li>ç»™å‡ºç¤ºä¾‹å€¼</li>
                    </ul>

                    <h3>5. æ€§èƒ½è€ƒè™‘</h3>
                    <ul>
                        <li>Pydantic è§£ææœ‰è½»å¾®æ€§èƒ½å¼€é”€</li>
                        <li>ç®€å•åœºæ™¯å¯ç”¨ <code>JsonOutputParser</code></li>
                        <li>æµå¼åœºæ™¯ä½¿ç”¨æµå¼è§£æå™¨</li>
                    </ul>
                </div>

                <h2>å¸¸è§é—®é¢˜</h2>

                <div class="warning" data-label="é—®é¢˜ï¼šè§£æå¤±è´¥">
                    <strong>é—®é¢˜</strong>ï¼šLLM è¾“å‡ºä¸æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼ã€‚
                    <br><br>
                    <strong>è§£å†³</strong>ï¼š
                    <ul>
                        <li>ä½¿ç”¨ <code>OutputFixingParser</code> è‡ªåŠ¨ä¿®å¤</li>
                        <li>åœ¨æç¤ºä¸­å¼ºè°ƒ JSON æ ¼å¼è¦æ±‚</li>
                        <li>æä¾› Few-shot ç¤ºä¾‹</li>
                    </ul>
                </div>

                <div class="warning" data-label="é—®é¢˜ï¼šå­—æ®µç¼ºå¤±">
                    <strong>é—®é¢˜</strong>ï¼šè§£æåçš„ JSON ç¼ºå°‘æŸäº›å­—æ®µã€‚
                    <br><br>
                    <strong>è§£å†³</strong>ï¼š
                    <ul>
                        <li>åœ¨ Field æè¿°ä¸­å¼ºè°ƒè¯¥å­—æ®µæ˜¯å¿…éœ€çš„</li>
                        <li>ä½¿ç”¨ <code>Field(default=...)</code> æä¾›é»˜è®¤å€¼</li>
                        <li>åœ¨æç¤ºä¸­æ˜ç¡®è¦æ±‚è¿”å›æ‰€æœ‰å­—æ®µ</li>
                    </ul>
                </div>

                <div class="warning" data-label="é—®é¢˜ï¼šç±»å‹ä¸åŒ¹é…">
                    <strong>é—®é¢˜</strong>ï¼šåº”è¯¥è¿”å›æ•°å­—ä½†è¿”å›äº†å­—ç¬¦ä¸²ã€‚
                    <br><br>
                    <strong>è§£å†³</strong>ï¼š
                    <ul>
                        <li>åœ¨ Field æè¿°ä¸­æ˜ç¡®æ•°æ®ç±»å‹</li>
                        <li>æä¾›å…·ä½“çš„ç¤ºä¾‹å€¼</li>
                        <li>è€ƒè™‘ä½¿ç”¨è‡ªå®šä¹‰åå¤„ç†è¿›è¡Œç±»å‹è½¬æ¢</li>
                    </ul>
                </div>

                <div class="exercise-section">
                    <h3>âœï¸ ç»ƒä¹ é¢˜</h3>

                    <div class="question">
                        <div class="question-title">
                            <span class="question-type">é€‰æ‹©é¢˜</span>
                            1. å“ªä¸ªè§£æå™¨æœ€é€‚åˆå°† LLM è¾“å‡ºè§£æä¸º Pydantic æ¨¡å‹ï¼Ÿ
                        </div>
                        <div class="options">
                            <div class="option">A. CommaSeparatedListOutputParser</div>
                            <div class="option correct-option">B. PydanticOutputParser</div>
                            <div class="option">C. StructuredOutputParser</div>
                            <div class="option">D. JsonOutputParser</div>
                        </div>
                    </div>

                    <div class="question">
                        <div class="question-title">
                            <span class="question-type">é€‰æ‹©é¢˜</span>
                            2. å½“ LLM è¾“å‡ºæ ¼å¼å¯èƒ½æœ‰é—®é¢˜æ—¶ï¼Œåº”è¯¥ä½¿ç”¨å“ªä¸ªè§£æå™¨ï¼Ÿ
                        </div>
                        <div class="options">
                            <div class="option">A. PydanticOutputParser</div>
                            <div class="option correct-option">B. OutputFixingParser</div>
                            <div class="option">C. CommaSeparatedListOutputParser</div>
                            <div class="option">D. è‡ªå®šä¹‰è§£æå™¨</div>
                        </div>
                    </div>

                    <div class="question">
                        <div class="question-title">
                            <span class="question-type">ä»£ç å¡«ç©º</span>
                            3. è¡¥å…¨ä»£ç ï¼šåˆ›å»ºä¸€ä¸ªè§£æå™¨æ¥æå–æ–‡ç« ä¿¡æ¯
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-language">python</span>
                                <button class="copy-btn">å¤åˆ¶</button>
                            </div>
                            <pre><code class="language-python">from pydantic import BaseModel, Field

class Article(BaseModel):
    title: str = Field(description="æ–‡ç« æ ‡é¢˜")
    author: str = Field(description="ä½œè€…")
    word_count: int = Field(description="å­—æ•°")
    tags: list[str] = Field(description="æ ‡ç­¾")

parser = ______(pydantic_object=Article)
instructions = parser.____()</code></pre>
                        </div>
                    </div>

                    <div class="question">
                        <div class="question-title">
                            <span class="question-type">ç¼–ç¨‹é¢˜</span>
                            4. åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰è§£æå™¨ï¼Œä»æ–‡æœ¬ä¸­æå–æ‰€æœ‰é‚®ä»¶åœ°å€
                        </div>
                    </div>

                    <div class="question">
                        <div class="question-title">
                            <span class="question-type">åœºæ™¯é¢˜</span>
                            5. ä½ æ­£åœ¨æ„å»ºä¸€ä¸ªå®¢æœæœºå™¨äººï¼Œéœ€è¦å°†ç”¨æˆ·æŸ¥è¯¢åˆ†ç±»ä¸º"æŠ€æœ¯æ”¯æŒ"ã€"è´¦å•é—®é¢˜"ã€"äº§å“å’¨è¯¢"ä¸‰ç±»ï¼Œå¹¶æå–ä¼˜å…ˆçº§ã€‚ä½ ä¼šå¦‚ä½•è®¾è®¡è¾“å‡ºè§£æï¼Ÿ
                        </div>
                    </div>
                </div>

                <div class="chapter-nav">
                    <a href="08-text-splitters.html">â† ä¸Šä¸€ç« ï¼šæ–‡æœ¬åˆ†å‰²</a>
                    <a href="10-memory.html" class="next">ä¸‹ä¸€ç« ï¼šè®°å¿†ç®¡ç† â†’</a>
                </div>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="../assets/js/main.js"></script>
</body>
</html>